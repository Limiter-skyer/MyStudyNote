数据结构是指计算机底层存储、组织数据的方式。是指数据相互之间是以什么方式排列在一起的。精心选择的数据结构会带来更高的效率。

# 常见的数据结构
- 栈
- 队列
- 数组
- 链表
- 二叉树
- 二叉查找树
- 平衡二叉树
- 黑红树

## 栈
栈仿佛一个杯子，上方开口下方封闭，先存储的数据在底部，后存储的数据在顶部。数据进入栈模型的过程称为：进栈、压栈。反之称为：出栈、弹栈。先进后出，后进先出。

## 队列
队列和现实生活中的的排队相似，是一个两端开口的容器。先到先得。先进先出，后进后出。
数据从后端进入称为：入队列；从前端离开队列称为：出队列。

## 数组
内存中的一块连续区域，查询速度快，因为查询数据是通过地址值和索引定位，查询任意数据耗时相同。
删除效率低：要将原始数据删除，同时后面每个数据前移。
添加效率极低：添加位置后的每个数据后移，再添加元素。

## 链表
链表中的元素在内存中是不连续储存的，每个元素节点包含数据值和下一个元素的地址。
链表有一个头地址，头地址数据为空，只有地址；最末端的地址只有数据，地址为空，添加元素时，下个元素的地址会填入空的地址
查询较慢，无论查哪个数据都得从头开始找。
增删较快（对比数组）：增删这个行为很快，但是找到增删的位置还是慢。

单向链表，从前往后找
双向链表：不仅储存了下一个数据的地址，而且保持了上一个数据的地址。

常用的时双向链表，首尾增删元素极快。

## 二叉树
二叉树，二叉树有父节点地址，左子节点地址，右子节点地址，加上自身的值。
节点的度：节点拥有的子树的个数，二叉树的度不大于2；子节点度为0的节点被称为终端节点。
高度：叶子节点的高度为1，其父节点高度为2，根节点高度最高。
![[Pasted image 20220718144801.png]]

## 二叉查找树
又称二叉排序树，或者，二叉搜索树。以二叉树为基础，其元素在二叉树内进行有序的排序，通过二分查找算法，**二叉查找树的查询效率极高**。
- 每一个节点上最多有两个子节点
- 左子树上所有的值都小于根节点的值
- 右子树上所有的值都大于根节点的值

![[Pasted image 20220718150909.png]]

二叉树的增删改查效率都非常高

## 平衡二叉树
二叉树查找存在的问题：当树的左右树枝的高度相差过大时，二叉树会降级成链表。称为“瘸子二叉树”

平衡二叉树时在满足查找二叉树的大小规则下，让树尽可能矮小。
平衡二叉树的规则：任意节点的左右两个子树的高度差不超过1；任意节点的两个左右子树都是平衡二叉树。
![[Pasted image 20220718152107.png]]
平衡二叉树在添加元素后可能导致不平衡。
基本策略是进行左旋或者右旋保持平衡。
- 左左
- 左右
- 右右
- 右左

## 红黑树
是一种自平衡的二叉查找树，是计算机科学中常用的一种数据结构。
1972年出现，当时被称之为平衡二叉B树。1978年被修改为如今的红黑树。
每一个节点可以是红或者黑；红黑树不是通过高度平衡的，它的平衡是通过“红黑规则”进行实现的。
红黑规则的效率极高

### 红黑规则：
1. 每一个节点或是红色或是黑色；根节点必须是黑色。
2. 如果一个节点没有子节点或者父节点，则该节点的相应指针属性为nil，这些nil视为叶节点，叶节点为黑色。
3. 如果某个节点是红色，那么它的子节点必须是黑色（不能出现两个红节点相连的情况）。
4. 对每个节点，从该节点到其所有后代的简单路径上，均包含相同数目的黑色节点。
![[Pasted image 20220718155209.png]]

红黑树多一个属性：颜色。

### 添加节点
添加节点的颜色，可以为红，也可以为黑
默认用红色效率更高

添加节点，（自身为红），当父节点为红，叔叔节点也为红的情况下：
1. 将父节点和叔叔节点都设置为黑，
2. 将父节点的父节点设置为红
3. 如果祖父节点为根节点，则再设置为黑。
4. 如果此刻祖父为红，且祖父节点的父节点也为红（冲突），则以祖父节点为支点进行选择。

# 各种数据结构的特点
- 队列：先进先出，后进后出
- 栈：后进先出，先进后出
- 数组：内存连续区域，按索引查询快，增删慢
- 链表：元素是游离的，查询慢，首位操作极快
- 二叉树：把单向的链表优化为双向的二叉树，效率提高，但是可以出现瘸子现象，降维成链表
- 查找二叉树：为了防止出现瘸子现象，在二叉树上增加了平衡的约束让二叉树的高度差不大于1，这种始终保持了数据查询的高效
- 黑红树：维护二叉树的最低熵状态（即高度差不大于1），本身就是一件成本极高的事情，有些情况下，并不是说要二叉树的平衡处于熵最低的状态，二叉树才能用；稍微容忍一些不平衡，会极大降低二叉树的维护成本。于是科学家开发出了红黑规则，这套规则可以维持二叉树的熵较低的情况下，不需要花过多的算力区维护黑红树。

java早就实现了这些数据结构，调用就行。